# 纸牌游戏程序设计文档
## 1.引言
本文档描述了基于 Cocos Creator 引擎开发的纸牌游戏核心模块的设计与实现。游戏采用 MVC（Model-View-Controller）架构，将数据、视图和逻辑分离，以提高代码的可维护性和可扩展性。文档详细说明了各模块的功能、关键类和方法，并重点阐述如何在现有结构下添加新卡牌类型和扩展撤销功能。

## 2.系统架构
游戏整体架构分为三层：
- **模型层（Model）**：负责存储和管理游戏数据，包括卡牌信息、区域状态和历史记录。该层与视图和控制器完全解耦，通过公共接口提供数据访问和修改。
- **视图层（View）**：负责卡牌的视觉呈现，监听用户输入并转发给控制器。视图不包含业务逻辑，仅通过更新界面反映模型状态。
- **控制器层（Controller）**：作为模型和视图之间的桥梁，处理用户交互，调用模型方法更新数据，并同步更新视图。
这种分层设计保证了各模块功能单一，便于后续功能扩展。

## 3.模块详细设计
### 3.1 模型层（Model）
模型层包含两个核心类：`CardData` 和 `GameModel`。

#### 3.1.1 `CardData` 类
- **文件位置**：`/models/CardData.ts`
- **功能**：定义单张卡牌的静态数据，为纯数据容器，不包含业务逻辑，易于扩展。
- **关键属性**：
  - `id: number` —— 卡牌唯一标识。
  - `face: number` —— 牌面点数（0–12 对应 A–K）。
  - `suit: number` —— 花色（0–3 对应梅花、方块、红心、黑桃）。
  - `area: string` —— 当前所在区域（如 `"main"`、`"stock"`、`"discard"`）。
  - `position: { x: number; y: number }` —— 界面坐标。

#### 3.1.2 `GameModel` 类
- **文件位置**：`/models/GameModel.ts`
- **功能**：
  - 管理所有卡牌实例（`Map<number, CardData>`）。
  - 提供区域和 ID 查询：`getCardsInArea(area)`、`getCardById(cardId)`。
  - 执行卡牌移动：`moveCard(cardId, targetArea, targetPos)`，并自动记录操作历史。
  - 撤销上一次移动：`undo()`，恢复卡牌状态。
- **核心设计**：
  - 历史记录采用栈结构（`_history` 数组），每次移动前将原状态入栈，撤销时出栈恢复。
  - 所有数据操作均通过公开方法进行，确保模型状态可控。
  - 模型层独立于引擎，便于单元测试或移植到其他平台。

### 3.2 视图层（View）
视图层核心类为 `CardView`，挂载于每个卡牌节点上。

#### 3.2.1 `CardView` 类
- **文件位置**：`/views/CardView.ts`
- **功能**：
  - 管理卡牌视觉元素（花色图案、大牌面、小数字）。
  - 提供 `updateDisplay(suit, face)` 方法，根据数据更新 `Sprite` 显示。
  - 存储所属卡牌 ID（`cardId`），便于控制器定位。
- **私有成员**：
  - `_suitSprite`、`_faceSprite`、`_numSprite` —— 三个子节点的 `Sprite` 组件。
  - 静态常量 `_kSuitNames` 和 `_kFaceNumbers` —— 用于资源路径映射。
- **生命周期**：
  - `onLoad()` 中查找并缓存子节点 `Sprite` 组件。
  - 资源加载通过 `_loadSprite(path, target)` 异步完成，确保显示正确。
- **设计要点**：视图仅负责显示，不持有数据状态，所有数据变化均由控制器触发视图更新。

### 3.3 控制器层（Controller）

控制器核心类为 `GameController`，是游戏的主入口组件。

#### 3.3.1 `GameController` 类
- **文件位置**：`/GameController.ts`
- **功能**：
  - 初始化游戏：加载配置文件，创建所有卡牌节点并绑定视图。
  - 处理用户点击：判断卡牌是否可移动，调用模型更新，并同步视图位置。
  - 响应撤销按钮：调用模型 `undo()`，并将卡牌节点移回原区域。
- **核心属性**：
  - `_model` —— `GameModel` 实例。
  - `_cardViewMap` —— 根据卡牌 ID 快速查找对应的 `CardView` 组件。
  - 通过 `@property` 暴露的节点引用（卡牌预制体、区域节点、按钮）。
- **关键方法**：
  - `_loadConfig()`：加载 JSON 配置并解析。
  - `_createCardNode(data)`：实例化预制体，设置位置，注册点击事件，并保存视图引用。
  - `_onCardClick(event)`：点击事件处理，调用 `_isCovered` 检查遮挡，根据区域决定移动逻辑。
  - `_moveCardToDiscard(cardId)`：将卡牌移至弃牌堆，更新模型和视图。
  - `_isCovered(cardNode)`：通过检测节点重叠判断是否被遮挡。
  - `isMatch(cardId)`：匹配规则判断（点数相差为 1 时匹配成功）。
  - `_onUndoClick()`：撤销按钮回调，调用模型 `undo()` 并移动节点。
  - `_getNodeForArea(area)`：区域名称到对应节点的映射。
- **设计要点**：控制器负责协调，不包含复杂业务逻辑，保证了各模块的低耦合。

## 4. 关键流程说明

### 4.1 游戏初始化流程

1. **启动场景**：`GameController.start()` 调用 `_loadConfig()`。
2. **加载配置文件**：`resources.load` 加载 `configs/stage.json`。
3. **解析数据并创建模型**：
   - 将 JSON 数据传入 `_model.loadData()`。
   - 模型内部创建所有 `CardData` 实例。
4. **创建卡牌视图**：控制器调用 `_createAllCards()`，遍历每个区域：
   - 实例化预制体，设置父节点和初始位置。
   - 获取 `CardView` 组件，设置 `cardId`，并调用 `updateDisplay()` 更新显示。
   - 将视图存入 `_cardViewMap`，方便后续查找。
   - 为节点绑定 `TOUCH_END` 事件。
5. **界面初始化**：更新撤销按钮的文字和交互状态。

### 4.2 卡牌点击移动流程

1. **触发点击**：用户点击卡牌，触发 `_onCardClick`。
2. **前置检查**：
   - 若卡牌被覆盖（`_isCovered` 为 `true`），直接忽略本次点击。
3. **根据当前位置决定行为**：
   - **弃牌堆**：不可移动（规则限制），流程结束。
   - **牌库**：直接调用 `_moveCardToDiscard`。
   - **牌桌区**：
     - 调用 `isMatch` 判断是否满足匹配规则。
     - 若满足，执行 `_moveCardToDiscard`。
     - 若不满足，提示匹配失败。
4. **执行移动（`_moveCardToDiscard`）**：
   - 调用模型 `moveCard` 更新数据，该操作会自动记录历史（当前区域/位置）。
   - 若移动成功，从 `_cardViewMap` 获取对应的视图节点。
   - 将节点从原父节点移除，添加到弃牌堆节点，并设置新位置。
5. **历史记录**：模型内部保存移动前的区域和位置，供撤销时恢复。

### 4.3 撤销流程

1. **用户触发**：点击“回退”按钮，调用 `_onUndoClick`。
2. **模型回退**：调用 `model.undo()`，获取上一次操作记录。
3. **恢复视图**：
   - 从 `_cardViewMap` 获取卡牌视图节点。
   - 根据记录中的 `oldArea`，通过 `_getNodeForArea` 获取目标父节点。
   - 将节点移动到该父节点，并设置 `oldPos` 位置。
4. **界面同步**：更新卡牌显示位置，完成回退。
## 5.扩展性设计
当前架构充分考虑了未来可能的需求变化，以下通过两个典型场景说明如何扩展功能。

### 5.1添加新卡牌类型
需求描述：在游戏中加入一种特殊卡牌“Joker”，它可以匹配任何牌面的卡牌（即 isMatch 始终返回 true）。同时需要在视觉上显示为独特的图案。

**修改步骤**  

1. **模型层扩展** 
   - 在 CardData 中添加新字段 `type: string`（默认 `"normal"`），用于区分普通牌和特殊牌。
   - 修改 JSON 配置文件，为 Joker 卡牌增加 `"type": "joker"` 字段。
   - 在 `GameModel.loadData()` 中解析该字段并传入 CardData 构造函数。
   - 修改 `GameModel.isMatch()` 方法：如果当前卡牌类型为 `"joker"` 或目标卡牌（弃牌堆顶）为 `"joker"`，直接返回 true；否则仍按点数差判断。

2. **视图层扩展** 
   - 在 CardView 中增加对特殊类型的处理：`updateDisplay` 可根据 type 参数加载不同的资源。
   - 例如，如果 `type === 'joker'`，则加载 `suits/joker/spriteFrame` 并隐藏或替换原有花色、牌面显示。

3. **控制器层扩展** 
   - 在 `_createCardNode` 中，从数据对象获取 type，并传递给 `cardView.updateDisplay(suit, face, type)`（需调整方法签名）。
   - 无需其他修改，点击和撤销逻辑由模型控制，自动适应新规则。

**优势说明** 
由于模型独立，只需修改 `isMatch` 和少量数据传递，即可实现新牌型，不影响现有代码结构。

### 5.2 添加多步撤销/重做功能
**需求描述**  
将当前的撤销功能扩展为支持多步撤销（可连续回退多次），并增加重做（Redo）功能。

**修改步骤**  

1. **模型层扩展**  
   - 将历史记录 `_history` 改为可索引结构，例如添加一个指针 `_currentIndex` 表示当前状态位置，历史记录数组保留所有操作。  
   - 修改 `moveCard` 方法：每次移动时，将新操作添加到历史记录，并清除指针之后的重做栈（如果存在）。  
   - 新增 `undo(steps: number = 1)` 方法：根据 `_currentIndex` 向前回退指定步数，恢复对应状态。  
   - 新增 `redo(steps: number = 1)` 方法：向后重做。  
   - 保留原有单步撤销接口（可内部调用多步实现）。

2. **控制器层扩展**  
   - 在界面上增加“重做”按钮，并绑定新方法 `_onRedoClick`。  
   - 修改 `_onUndoClick` 调用模型的新 `undo(1)`。  
   - 在撤销/重做后，需要遍历所有受影响的卡牌并更新其视图位置。简单实现可重新查询每个区域的卡牌列表并更新节点父子关系，但更高效的方式是从历史记录中获取具体变更的卡牌 ID，仅更新这些节点。  
   - 由于视图与模型通过 `_cardViewMap` 关联，可以快速定位卡牌节点进行移动。

**优势说明**  
历史记录的管理完全封装在模型内，控制器只需调用新接口并更新受影响视图。模型层的改动不影响已有外部调用（原有 `undo()` 可保留作为默认单步撤销），符合开闭原则。

## 6.总结
本卡牌游戏程序设计遵循 MVC 模式和清晰的分层原则，各模块功能明确，接口简洁。通过合理使用私有成员命名规范、常量定义和详细注释，代码具备良好的可读性和可维护性。在扩展性方面，模型层的独立性和视图与控制器的松耦合使得添加新卡牌类型、修改匹配规则、增强撤销功能等需求均可在局部范围内完成，无需重构整体架构。该设计为后续迭代和功能增强奠定了坚实基础。